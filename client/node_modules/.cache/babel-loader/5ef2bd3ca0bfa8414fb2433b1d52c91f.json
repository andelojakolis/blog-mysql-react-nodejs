{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChangeStreamCursor = void 0;\n\nconst change_stream_1 = require(\"../change_stream\");\n\nconst constants_1 = require(\"../constants\");\n\nconst aggregate_1 = require(\"../operations/aggregate\");\n\nconst execute_operation_1 = require(\"../operations/execute_operation\");\n\nconst utils_1 = require(\"../utils\");\n\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\n\n\nclass ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(client, namespace) {\n    let pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(client, namespace, options);\n    this.pipeline = pipeline;\n    this.options = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n\n  get resumeToken() {\n    return this._resumeToken;\n  }\n\n  get resumeOptions() {\n    const options = { ...this.options\n    };\n\n    for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime']) {\n      delete options[key];\n    }\n\n    if (this.resumeToken != null) {\n      if (this.options.startAfter && !this.hasReceived) {\n        options.startAfter = this.resumeToken;\n      } else {\n        options.resumeAfter = this.resumeToken;\n      }\n    } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {\n      options.startAtOperationTime = this.startAtOperationTime;\n    }\n\n    return options;\n  }\n\n  cacheResumeToken(resumeToken) {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n\n    this.hasReceived = true;\n  }\n\n  _processBatch(response) {\n    const cursor = response.cursor;\n\n    if (cursor.postBatchResumeToken) {\n      this.postBatchResumeToken = response.cursor.postBatchResumeToken;\n      const batch = 'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;\n\n      if (batch.length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n\n  clone() {\n    return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, { ...this.cursorOptions\n    });\n  }\n\n  _initialize(session, callback) {\n    const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, { ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, (err, response) => {\n      if (err || response == null) {\n        return callback(err);\n      }\n\n      const server = aggregateOperation.server;\n      this.maxWireVersion = (0, utils_1.maxWireVersion)(server);\n\n      if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && this.maxWireVersion >= 7) {\n        this.startAtOperationTime = response.operationTime;\n      }\n\n      this._processBatch(response);\n\n      this.emit(constants_1.INIT, response);\n      this.emit(constants_1.RESPONSE); // TODO: NODE-2882\n\n      callback(undefined, {\n        server,\n        session,\n        response\n      });\n    });\n  }\n\n  _getMore(batchSize, callback) {\n    super._getMore(batchSize, (err, response) => {\n      if (err) {\n        return callback(err);\n      }\n\n      this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);\n\n      this._processBatch(response);\n\n      this.emit(change_stream_1.ChangeStream.MORE, response);\n      this.emit(change_stream_1.ChangeStream.RESPONSE);\n      callback(err, response);\n    });\n  }\n\n}\n\nexports.ChangeStreamCursor = ChangeStreamCursor;","map":{"version":3,"mappings":"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","names":["ChangeStreamCursor","abstract_cursor_1","constructor","client","namespace","pipeline","options","_resumeToken","startAtOperationTime","startAfter","resumeToken","resumeAfter","token","emit","change_stream_1","RESUME_TOKEN_CHANGED","resumeOptions","key","hasReceived","server","cacheResumeToken","bufferedCount","postBatchResumeToken","_processBatch","response","cursor","batch","firstBatch","nextBatch","length","clone","cursorOptions","_initialize","session","callback","aggregateOperation","aggregate_1","err","maxWireVersion","operationTime","constants_1","undefined","_getMore","batchSize","MORE","RESPONSE","exports"],"sources":["C:\\Users\\AnÄ‘elo\\node_modules\\mongodb\\src\\cursor\\change_stream_cursor.ts"],"sourcesContent":["import type { Document, Long, Timestamp } from '../bson';\nimport {\n  type ChangeStreamDocument,\n  type ChangeStreamEvents,\n  type OperationTime,\n  type ResumeToken,\n  ChangeStream\n} from '../change_stream';\nimport { INIT, RESPONSE } from '../constants';\nimport type { MongoClient } from '../mongo_client';\nimport type { TODO_NODE_3286 } from '../mongo_types';\nimport { AggregateOperation } from '../operations/aggregate';\nimport type { CollationOptions } from '../operations/command';\nimport { type ExecutionResult, executeOperation } from '../operations/execute_operation';\nimport type { ClientSession } from '../sessions';\nimport { type Callback, type MongoDBNamespace, maxWireVersion } from '../utils';\nimport { type AbstractCursorOptions, AbstractCursor } from './abstract_cursor';\n\n/** @internal */\nexport interface ChangeStreamCursorOptions extends AbstractCursorOptions {\n  startAtOperationTime?: OperationTime;\n  resumeAfter?: ResumeToken;\n  startAfter?: ResumeToken;\n  maxAwaitTimeMS?: number;\n  collation?: CollationOptions;\n  fullDocument?: string;\n}\n\n/** @internal */\nexport type ChangeStreamAggregateRawResult<TChange> = {\n  $clusterTime: { clusterTime: Timestamp };\n  cursor: {\n    postBatchResumeToken: ResumeToken;\n    ns: string;\n    id: number | Long;\n  } & ({ firstBatch: TChange[] } | { nextBatch: TChange[] });\n  ok: 1;\n  operationTime: Timestamp;\n};\n\n/** @internal */\nexport class ChangeStreamCursor<\n  TSchema extends Document = Document,\n  TChange extends Document = ChangeStreamDocument<TSchema>\n> extends AbstractCursor<TChange, ChangeStreamEvents> {\n  _resumeToken: ResumeToken;\n  startAtOperationTime?: OperationTime;\n  hasReceived?: boolean;\n  resumeAfter: ResumeToken;\n  startAfter: ResumeToken;\n  options: ChangeStreamCursorOptions;\n\n  postBatchResumeToken?: ResumeToken;\n  pipeline: Document[];\n\n  /**\n   * @internal\n   *\n   * used to determine change stream resumability\n   */\n  maxWireVersion: number | undefined;\n\n  constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    pipeline: Document[] = [],\n    options: ChangeStreamCursorOptions = {}\n  ) {\n    super(client, namespace, options);\n\n    this.pipeline = pipeline;\n    this.options = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token: ResumeToken) {\n    this._resumeToken = token;\n    this.emit(ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n\n  get resumeToken(): ResumeToken {\n    return this._resumeToken;\n  }\n\n  get resumeOptions(): ChangeStreamCursorOptions {\n    const options: ChangeStreamCursorOptions = {\n      ...this.options\n    };\n\n    for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime'] as const) {\n      delete options[key];\n    }\n\n    if (this.resumeToken != null) {\n      if (this.options.startAfter && !this.hasReceived) {\n        options.startAfter = this.resumeToken;\n      } else {\n        options.resumeAfter = this.resumeToken;\n      }\n    } else if (this.startAtOperationTime != null && maxWireVersion(this.server) >= 7) {\n      options.startAtOperationTime = this.startAtOperationTime;\n    }\n\n    return options;\n  }\n\n  cacheResumeToken(resumeToken: ResumeToken): void {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n    this.hasReceived = true;\n  }\n\n  _processBatch(response: ChangeStreamAggregateRawResult<TChange>): void {\n    const cursor = response.cursor;\n    if (cursor.postBatchResumeToken) {\n      this.postBatchResumeToken = response.cursor.postBatchResumeToken;\n\n      const batch =\n        'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;\n      if (batch.length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n\n  clone(): AbstractCursor<TChange> {\n    return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {\n      ...this.cursorOptions\n    });\n  }\n\n  _initialize(session: ClientSession, callback: Callback<ExecutionResult>): void {\n    const aggregateOperation = new AggregateOperation(this.namespace, this.pipeline, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n\n    executeOperation<TODO_NODE_3286, ChangeStreamAggregateRawResult<TChange>>(\n      session.client,\n      aggregateOperation,\n      (err, response) => {\n        if (err || response == null) {\n          return callback(err);\n        }\n\n        const server = aggregateOperation.server;\n        this.maxWireVersion = maxWireVersion(server);\n\n        if (\n          this.startAtOperationTime == null &&\n          this.resumeAfter == null &&\n          this.startAfter == null &&\n          this.maxWireVersion >= 7\n        ) {\n          this.startAtOperationTime = response.operationTime;\n        }\n\n        this._processBatch(response);\n\n        this.emit(INIT, response);\n        this.emit(RESPONSE);\n\n        // TODO: NODE-2882\n        callback(undefined, { server, session, response });\n      }\n    );\n  }\n\n  override _getMore(batchSize: number, callback: Callback): void {\n    super._getMore(batchSize, (err, response) => {\n      if (err) {\n        return callback(err);\n      }\n\n      this.maxWireVersion = maxWireVersion(this.server);\n      this._processBatch(response as TODO_NODE_3286 as ChangeStreamAggregateRawResult<TChange>);\n\n      this.emit(ChangeStream.MORE, response);\n      this.emit(ChangeStream.RESPONSE);\n      callback(err, response);\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CreateCollectionOperation = void 0;\n\nconst collection_1 = require(\"../collection\");\n\nconst command_1 = require(\"./command\");\n\nconst indexes_1 = require(\"./indexes\");\n\nconst operation_1 = require(\"./operation\");\n\nconst ILLEGAL_COMMAND_FIELDS = new Set(['w', 'wtimeout', 'j', 'fsync', 'autoIndexId', 'pkFactory', 'raw', 'readPreference', 'session', 'readConcern', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation']);\n/** @internal */\n\nclass CreateCollectionOperation extends command_1.CommandOperation {\n  constructor(db, name) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(db, options);\n    this.options = options;\n    this.db = db;\n    this.name = name;\n  }\n\n  execute(server, session, callback) {\n    (async () => {\n      var _a, _b, _c, _d, _e, _f;\n\n      const db = this.db;\n      const name = this.name;\n      const options = this.options;\n      const encryptedFields = (_a = options.encryptedFields) !== null && _a !== void 0 ? _a : (_c = (_b = db.s.client.options.autoEncryption) === null || _b === void 0 ? void 0 : _b.encryptedFieldsMap) === null || _c === void 0 ? void 0 : _c[`${db.databaseName}.${name}`];\n\n      if (encryptedFields) {\n        // Create auxilliary collections for queryable encryption support.\n        const escCollection = (_d = encryptedFields.escCollection) !== null && _d !== void 0 ? _d : `enxcol_.${name}.esc`;\n        const eccCollection = (_e = encryptedFields.eccCollection) !== null && _e !== void 0 ? _e : `enxcol_.${name}.ecc`;\n        const ecocCollection = (_f = encryptedFields.ecocCollection) !== null && _f !== void 0 ? _f : `enxcol_.${name}.ecoc`;\n\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          const createOp = new CreateCollectionOperation(db, collectionName, {\n            clusteredIndex: {\n              key: {\n                _id: 1\n              },\n              unique: true\n            }\n          });\n          await createOp.executeWithoutEncryptedFieldsCheck(server, session);\n        }\n\n        if (!options.encryptedFields) {\n          this.options = { ...this.options,\n            encryptedFields\n          };\n        }\n      }\n\n      const coll = await this.executeWithoutEncryptedFieldsCheck(server, session);\n\n      if (encryptedFields) {\n        // Create the required index for queryable encryption support.\n        const createIndexOp = new indexes_1.CreateIndexOperation(db, name, {\n          __safeContent__: 1\n        }, {});\n        await new Promise((resolve, reject) => {\n          createIndexOp.execute(server, session, err => err ? reject(err) : resolve());\n        });\n      }\n\n      return coll;\n    })().then(coll => callback(undefined, coll), err => callback(err));\n  }\n\n  executeWithoutEncryptedFieldsCheck(server, session) {\n    return new Promise((resolve, reject) => {\n      const db = this.db;\n      const name = this.name;\n      const options = this.options;\n\n      const done = err => {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(new collection_1.Collection(db, name, options));\n      };\n\n      const cmd = {\n        create: name\n      };\n\n      for (const n in options) {\n        if (options[n] != null && typeof options[n] !== 'function' && !ILLEGAL_COMMAND_FIELDS.has(n)) {\n          cmd[n] = options[n];\n        }\n      } // otherwise just execute the command\n\n\n      super.executeCommand(server, session, cmd, done);\n    });\n  }\n\n}\n\nexports.CreateCollectionOperation = CreateCollectionOperation;\n(0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"mappings":"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","names":["ILLEGAL_COMMAND_FIELDS","Set","CreateCollectionOperation","command_1","constructor","db","name","options","execute","server","session","callback","encryptedFields","_a","s","client","autoEncryption","_b","encryptedFieldsMap","_c","databaseName","escCollection","_d","eccCollection","_e","ecocCollection","_f","collectionName","createOp","clusteredIndex","key","_id","unique","executeWithoutEncryptedFieldsCheck","coll","createIndexOp","indexes_1","__safeContent__","Promise","resolve","reject","err","then","undefined","done","collection_1","cmd","create","n","has","executeCommand","exports","operation_1","WRITE_OPERATION"],"sources":["C:\\Users\\AnÄ‘elo\\node_modules\\mongodb\\src\\operations\\create_collection.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport { Collection } from '../collection';\nimport type { Db } from '../db';\nimport type { PkFactory } from '../mongo_client';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport type { Callback } from '../utils';\nimport { CommandOperation, CommandOperationOptions } from './command';\nimport { CreateIndexOperation } from './indexes';\nimport { Aspect, defineAspects } from './operation';\n\nconst ILLEGAL_COMMAND_FIELDS = new Set([\n  'w',\n  'wtimeout',\n  'j',\n  'fsync',\n  'autoIndexId',\n  'pkFactory',\n  'raw',\n  'readPreference',\n  'session',\n  'readConcern',\n  'writeConcern',\n  'raw',\n  'fieldsAsRaw',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'bsonRegExp',\n  'serializeFunctions',\n  'ignoreUndefined',\n  'enableUtf8Validation'\n]);\n\n/** @public\n * Configuration options for timeseries collections\n * @see https://docs.mongodb.com/manual/core/timeseries-collections/\n */\nexport interface TimeSeriesCollectionOptions extends Document {\n  timeField: string;\n  metaField?: string;\n  granularity?: 'seconds' | 'minutes' | 'hours' | string;\n}\n\n/** @public\n * Configuration options for clustered collections\n * TODO: NODE-4230 replace with normal manual link once it is on there.\n * @see https://www.mongodb.com/docs/v5.3/core/clustered-collections/\n */\nexport interface ClusteredCollectionOptions extends Document {\n  name?: string;\n  key: Document;\n  unique: boolean;\n}\n\n/** @public */\nexport interface CreateCollectionOptions extends CommandOperationOptions {\n  /** Returns an error if the collection does not exist */\n  strict?: boolean;\n  /** Create a capped collection */\n  capped?: boolean;\n  /** @deprecated Create an index on the _id field of the document, True by default on MongoDB 2.6 - 3.0 */\n  autoIndexId?: boolean;\n  /** The size of the capped collection in bytes */\n  size?: number;\n  /** The maximum number of documents in the capped collection */\n  max?: number;\n  /** Available for the MMAPv1 storage engine only to set the usePowerOf2Sizes and the noPadding flag */\n  flags?: number;\n  /** Allows users to specify configuration to the storage engine on a per-collection basis when creating a collection on MongoDB 3.0 or higher */\n  storageEngine?: Document;\n  /** Allows users to specify validation rules or expressions for the collection. For more information, see Document Validation on MongoDB 3.2 or higher */\n  validator?: Document;\n  /** Determines how strictly MongoDB applies the validation rules to existing documents during an update on MongoDB 3.2 or higher */\n  validationLevel?: string;\n  /** Determines whether to error on invalid documents or just warn about the violations but allow invalid documents to be inserted on MongoDB 3.2 or higher */\n  validationAction?: string;\n  /** Allows users to specify a default configuration for indexes when creating a collection on MongoDB 3.2 or higher */\n  indexOptionDefaults?: Document;\n  /** The name of the source collection or view from which to create the view. The name is not the full namespace of the collection or view; i.e. does not include the database name and implies the same database as the view to create on MongoDB 3.4 or higher */\n  viewOn?: string;\n  /** An array that consists of the aggregation pipeline stage. Creates the view by applying the specified pipeline to the viewOn collection or view on MongoDB 3.4 or higher */\n  pipeline?: Document[];\n  /** A primary key factory function for generation of custom _id keys. */\n  pkFactory?: PkFactory;\n  /** A document specifying configuration options for timeseries collections. */\n  timeseries?: TimeSeriesCollectionOptions;\n  /** A document specifying configuration options for clustered collections. For MongoDB 5.3 and above. */\n  clusteredIndex?: ClusteredCollectionOptions;\n  /** The number of seconds after which a document in a timeseries or clustered collection expires. */\n  expireAfterSeconds?: number;\n  /** @experimental */\n  encryptedFields?: Document;\n  /**\n   * If set, enables pre-update and post-update document events to be included for any\n   * change streams that listen on this collection.\n   */\n  changeStreamPreAndPostImages?: { enabled: boolean };\n}\n\n/** @internal */\nexport class CreateCollectionOperation extends CommandOperation<Collection> {\n  override options: CreateCollectionOptions;\n  db: Db;\n  name: string;\n\n  constructor(db: Db, name: string, options: CreateCollectionOptions = {}) {\n    super(db, options);\n\n    this.options = options;\n    this.db = db;\n    this.name = name;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Collection>\n  ): void {\n    (async () => {\n      const db = this.db;\n      const name = this.name;\n      const options = this.options;\n\n      const encryptedFields: Document | undefined =\n        options.encryptedFields ??\n        db.s.client.options.autoEncryption?.encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n\n      if (encryptedFields) {\n        // Create auxilliary collections for queryable encryption support.\n        const escCollection = encryptedFields.escCollection ?? `enxcol_.${name}.esc`;\n        const eccCollection = encryptedFields.eccCollection ?? `enxcol_.${name}.ecc`;\n        const ecocCollection = encryptedFields.ecocCollection ?? `enxcol_.${name}.ecoc`;\n\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          const createOp = new CreateCollectionOperation(db, collectionName, {\n            clusteredIndex: {\n              key: { _id: 1 },\n              unique: true\n            }\n          });\n          await createOp.executeWithoutEncryptedFieldsCheck(server, session);\n        }\n\n        if (!options.encryptedFields) {\n          this.options = { ...this.options, encryptedFields };\n        }\n      }\n\n      const coll = await this.executeWithoutEncryptedFieldsCheck(server, session);\n\n      if (encryptedFields) {\n        // Create the required index for queryable encryption support.\n        const createIndexOp = new CreateIndexOperation(db, name, { __safeContent__: 1 }, {});\n        await new Promise<void>((resolve, reject) => {\n          createIndexOp.execute(server, session, err => (err ? reject(err) : resolve()));\n        });\n      }\n\n      return coll;\n    })().then(\n      coll => callback(undefined, coll),\n      err => callback(err)\n    );\n  }\n\n  private executeWithoutEncryptedFieldsCheck(\n    server: Server,\n    session: ClientSession | undefined\n  ): Promise<Collection> {\n    return new Promise<Collection>((resolve, reject) => {\n      const db = this.db;\n      const name = this.name;\n      const options = this.options;\n\n      const done: Callback = err => {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(new Collection(db, name, options));\n      };\n\n      const cmd: Document = { create: name };\n      for (const n in options) {\n        if (\n          (options as any)[n] != null &&\n          typeof (options as any)[n] !== 'function' &&\n          !ILLEGAL_COMMAND_FIELDS.has(n)\n        ) {\n          cmd[n] = (options as any)[n];\n        }\n      }\n\n      // otherwise just execute the command\n      super.executeCommand(server, session, cmd, done);\n    });\n  }\n}\n\ndefineAspects(CreateCollectionOperation, [Aspect.WRITE_OPERATION]);\n"]},"metadata":{},"sourceType":"script"}